[manifest]
dump_lua = true
priority = 0
version = "1.0.0"

# Undo Copy ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''copies = copies or {}'''
payload = '''
if getmetatable(orig) and getmetatable(orig).beattoolsUndoInject then
	orig = getmetatable(orig).hidden
end
'''
position = "after"
target = "lib/helpers.lua"

# Ratemod ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.innerOptionsMenu:addNumber('ratemod', self, 'rateMod', 0, 0.1, {0.5, 5}, function() if cs.source then cs.source:setPitch(cs.rateMod) end end)'''
payload = '''self.innerOptionsMenu:addNumber('ratemod', self, 'rateMod', 0, 0.1, mods.beattools.config.rateModLimits and {0.01, 50} or {0.5, 5}, function() if cs.source then cs.source:setPitch(cs.rateMod) end end)'''
position = "at"
target = "states/SongSelect.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.innerOptionsMenu:addNumber("ratemod", self, "rateMod", 0, 0.1, { 0.5, 5 }, function() if cs.source then cs.source:setPitch(cs.rateMod) end end)'''
payload = '''self.innerOptionsMenu:addNumber("ratemod", self, "rateMod", 0, 0.1, mods.beattools.config.rateModLimits and { 0.01, 50 } or { 0.5, 5 }, function() if cs.source then cs.source:setPitch(cs.rateMod) end end)'''
position = "at"
target = "states/AtomMap.lua"

# Multiselect delta ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.multieditdeltamode = false'''
payload = '''self.multieditdeltamode = (function () if mods.beattools.config.rememberMultiselectDelta then return mods.beattools.config.multiselectDelta end return false end)()'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.multieditdeltamode = helpers.InputBool('Delta Mode', self.multieditdeltamode)'''
payload = '''
if mods.beattools.config.rememberMultiselectDelta then
	mods.beattools.config.multiselectDelta = helpers.InputBool('Delta Mode', mods.beattools.config.multiselectDelta)
	self.multieditdeltamode = mods.beattools.config.multiselectDelta
else
	self.multieditdeltamode = helpers.InputBool('Delta Mode', self.multieditdeltamode)
end
'''
position = "at"
target = "states/Editor.lua"

# Ignore loop points ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.levelData and self.levelData.metadata.loopPointsEnable then'''
payload = '''if not mods.beattools.config.ignoreLoopPoints and self.levelData and self.levelData.metadata.loopPointsEnable then'''
position = "at"
target = "states/SongSelect.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.levelData.metadata.loopPointsEnable then'''
payload = '''if not mods.beattools.config.ignoreLoopPoints and self.levelData and self.levelData.metadata.loopPointsEnable then'''
position = "at"
target = "obj/Map/LevelQuark.lua"

# Copy single event ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''
	end
end,
'copy',
'''
payload = '''
		self.copySingle = false
	elseif mods.beattools.config.copySingle and self.selectedEvent then
		self.copy = helpers.copy({ self.selectedEvent })
		self.copy[1].time = 0
		self.copySize = 0

		self.multiselectCopyStartAngle = 0
		self.multiselectCopyEndAngle = 360

		self.p:hurtPulse()
		self.copySingle = true
	end
end,
'copy',
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.multiselectEndAngle = self.multiselectCopyEndAngle'''
payload = '''
if mods.beattools.config.copySingle and self.copySingle then
	self:clearMultiselectVars()
	self:noSelection()
	self.selectedEvent = newEvents[1]
end
'''
position = "after"
target = "states/Editor.lua"

# Ctrl select ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = false
pattern = '''self.selectedEvent = self.level.events[self.overlappingEvents[1]]
end'''
payload = '''		if self.selectedEvent then'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = false
pattern = '''' event. ' .. self.selectedEvent.angle .. '|' .. self.selectedEvent.time,'editor')'''
payload = '''		end'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.lastClickX, self.lastClickY = mouse.rx, mouse.ry'''
payload = '''
self.lastSelected = self.selectedEvent
self.ctrlSelectPending = mods.beattools.config.ctrlSelect and maininput:down("ctrl")
'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''function st:SelectEvent()
	self:clearMultiselectVars()'''
payload = '''
function st:SelectEvent()
	if not mods.beattools.config.ctrlSelect or not maininput:down("ctrl") then self:clearMultiselectVars() end
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if maininput:down("ctrl") then'''
payload = '''
if mods.beattools.config.ctrlSelect and maininput:down("ctrl") then
	self:beattoolsCtrlSelect(self.level.events[self.overlappingEvents[1]])
elseif (mods.beattools.config.ctrlSelect and maininput:down("c")) or (not mods.beattools.config.ctrlSelect and maininput:down("ctrl")) then
'''
position = "at"
target = "states/Editor.lua"

# Overlapping ctrl select ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if imgui.Selectable_Bool(Event.info[e.type].name .. ' (ID ' .. v .. ')') then'''
payload = '''
if imgui.Selectable_Bool(
	Event.info[e.type].name .. ' (ID ' .. v .. ')',
	mods.beattools.config.ctrlSelect and self.ctrlSelectPending and self.multiselect and self.multiselect.events and (beatblockPlus2_0Update and bbp.utils.tableContains or tableContains)(self.multiselect.events, self.level.events[v])
) then
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.deletePending then'''
payload = '''
if mods.beattools.config.ctrlSelect and self.ctrlSelectPending then
	imgui.Text("Select which event to ctrl select:")
elseif self.deletePending then
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.selectedEvent = self.level.events[v]
-- Changes cursor angle to match event angle
self.cursorAngle = self.selectedEvent.angle'''
payload = '''
if mods.beattools.config.ctrlSelect and self.ctrlSelectPending then
	self:beattoolsCtrlSelect(self.level.events[v])
	self.ctrlSelectPending = false
	self.cursorAngle = self.level.events[v].angle
else
	self.ctrlSelectPending = false
	self:noSelection()
	self.selectedEvent = self.level.events[v]
	-- Changes cursor angle to match event angle
	self.cursorAngle = self.selectedEvent.angle
end
'''
position = "at"
target = "states/Editor.lua"

# Optionslist movement fix ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.cooldownMax = 10'''
payload = '''self.cooldownMax = mods.beattools.config.speedScrolling and 0 or 10'''
position = "at"
target = "obj/OptionsList.lua"

# Multiselect movement fix ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''
self.multiselectStartAngle = self.multiselectStartAngle + angle
self.multiselectEndAngle = self.multiselectEndAngle + angle
'''
payload = '''
if not (self.multiselectStartAngle == 0 and self.multiselectEndAngle == 360) then
	self.multiselectStartAngle = self.multiselectStartAngle + angle
	self.multiselectEndAngle = self.multiselectEndAngle + angle
end
'''
position = "at"
target = "states/Editor.lua"

# Bounce dragging ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.overlappingEvents = {}'''
payload = '''local prevOverlapping = self.overlappingEvents
local prevBounceSelect = self.bounceSelected
local prevBounceSelectTime = self.bounceSelectTime
self.bounceSelected = false
self.bounceSelectTime = 0
self.bounceSelectAccumulation = 0
local bounceSelection = {}'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''-- check end of holds as well'''
payload = '''
-- check bounces of bounces as well
if mods.beattools.config.bounceDragging and v.type == "bounce" and (v.bounces or 1) > 0 and ((not mods.beattools.config.fakeRepeat) or v.beattoolsRepeatChild == nil) and not ({ ghost = true, hide = true })[utilitools.files.beattools.eventGroups.eventVisibility(v)] then
	for ii = 1, (v.bounces or 1) do
		local pos2 = self:getPosition((mods.beattools.config.displayEndAngle and v.endAngle or v.angle) + (v.rotation or 0) * ii, v.time + (v.delay or 1) * ii)
		if helpers.collide(
			{ x = mouse.rx, y = mouse.ry, width = 0, height = 0 },
			{ x = pos2[1] - 8, y = pos2[2] - 8, width = 16, height = 16 }) then
			table.insert(self.overlappingEvents, i)
			table.insert(bounceSelection, { i, ii })
		end
	end
end
'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''for _, v in ipairs(holdEndSelection) do'''
payload = '''
for _, v in ipairs(bounceSelection) do
	if v[1] == self.overlappingEvents[1] then
		self.bounceSelected = v[2]
		if prevOverlapping and #prevOverlapping == 1 and prevOverlapping[1] == self.overlappingEvents[1] and prevBounceSelectTime and prevBounceSelectTime ~= 0 and (beattoolsTime - prevBounceSelectTime) / 60 <= 0.5 then
			modlog(mods.beattools, "Double clicked bounce")
			self.bounceSelectTime = -1
		else
			self.bounceSelectTime = beattoolsTime
		end
		break
	end
end
'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if not self.holdEndSelected then
	self.selectedEvent.time = self.selectedEvent.time + beat'''
payload = '''
if mods.beattools.config.bounceDragging and self.bounceSelected then
	if mods.beattools.config.bounceDoubleClick and self.bounceSelectTime == -1 then
		self.bounceSelectAccumulation = self.bounceSelectAccumulation + beat
		if math.abs(self.bounceSelectAccumulation) >= (self.selectedEvent.delay or 1) then
			local bounceDiff = math.floor(self.bounceSelectAccumulation / (self.selectedEvent.delay or 1))
			self.selectedEvent.bounces = math.max(self.selectedEvent.bounces + bounceDiff, 1)
			self.bounceSelected = math.max(self.bounceSelected + bounceDiff, 1)
			self.bounceSelectAccumulation = self.bounceSelectAccumulation % (self.selectedEvent.delay or 1)
		end
	else
		-- If the user is holding a bounced bounce, we only move the rotation/delay.
		self.selectedEvent.rotation = (self.selectedEvent.rotation or 0) + angle / self.bounceSelected
		self.selectedEvent.delay = math.max((self.selectedEvent.delay or 1) + beat / self.bounceSelected, 0)
	end
elseif not self.holdEndSelected then
	self.selectedEvent.time = self.selectedEvent.time + beat
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local angle = self.cursorAngle

					if not self.holdEndSelected then'''
payload = '''
local angle = self.cursorAngle
if mods.beattools.config.bounceDragging and self.bounceSelected then
	if mods.beattools.config.bounceDoubleClick and self.bounceSelectTime == -1 then
		local timeDiff = self.cursorBeat - (self.selectedEvent.time + (self.selectedEvent.delay or 1) * self.bounceSelected)
		if math.abs(timeDiff) >= (self.selectedEvent.delay or 1) then
			local bounceDiff = math.floor(timeDiff / (self.selectedEvent.delay or 1))
			self.selectedEvent.bounces = math.max(self.selectedEvent.bounces + bounceDiff, 1)
			self.bounceSelected = math.max(self.bounceSelected + bounceDiff, 1)
			self.bounceSelectAccumulation = 0
		end
	else
		-- see next comment on what this does. - bliv - Penta
		angle = helpers.closestAngle(angle, self.selectedEvent.angle + (self.selectedEvent.rotation or 0) * self.bounceSelected)

		self.selectedEvent.rotation = (angle - self.selectedEvent.angle) / self.bounceSelected
		self.selectedEvent.delay = math.max(self.selectedEvent.delay + (self.cursorBeat - (self.selectedEvent.time + (self.selectedEvent.delay or 1) * self.bounceSelected)) / self.bounceSelected, 0)
	end
elseif not self.holdEndSelected then
'''
position = "at"
target = "states/Editor.lua"

# Fix for penta's dream skin ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if bodyShape == "2p5d" then'''
payload = '''
if costume.body and (bodyShape ~= "2p5d" or costume.body.bodyInvisible) and costume.body.body2p5d then
	if costume.body.bodyInvisible then bodyShape = "invisible" end
	self:drawToCanvas(costume, bodyShape, 3)
	self:drawToCanvas(costume, bodyShape, 0)
elseif bodyShape == "2p5d" then
'''
position = "at"
target = "obj/Player.lua"

# Event transparency drawing ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
# Block
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event)'''
payload = '''local function editorDraw(event, a, b, alpha)'''
position = "at"
target = "levelformat/events/Notes/block.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local note = Block:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/block.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''color()'''
payload = '''love.graphics.setColor(1, 1, 1, self.beattoolsAlpha or 1)'''
position = "after"
target = "obj/notes/Block.lua"

# Inverse
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event)'''
payload = '''local function editorDraw(event, a, b, alpha)'''
position = "at"
target = "levelformat/events/Notes/inverse.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local note = Block:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/inverse.lua"

# Side
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event)'''
payload = '''local function editorDraw(event, a, b, alpha)'''
position = "at"
target = "levelformat/events/Notes/side.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local note = Side:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/side.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''color()'''
payload = '''love.graphics.setColor(1, 1, 1, self.beattoolsAlpha or 1)'''
position = "after"
target = "obj/notes/Side.lua"

# Mine
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event)'''
payload = '''local function editorDraw(event, a, b, alpha)'''
position = "at"
target = "levelformat/events/Notes/mine.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local note = Mine:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/mine.lua"

# Hold
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event, beat, endBeat)'''
payload = '''local function editorDraw(event, beat, endBeat, alpha)'''
position = "at"
target = "levelformat/events/Notes/hold.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local hold = Hold:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/hold.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''color()'''
payload = '''love.graphics.setColor(1, 1, 1, self.beattoolsAlpha or 1)'''
position = "after"
target = "obj/notes/Hold.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''color('black')'''
payload = '''love.graphics.setColor(0, 0, 0, self.beattoolsAlpha or 1)'''
position = "after"
target = "obj/notes/Hold.lua"

# Minehold
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local function editorDraw(event, beat, endBeat)'''
payload = '''local function editorDraw(event, beat, endBeat, alpha)'''
position = "at"
target = "levelformat/events/Notes/mineHold.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local hold = MineHold:new({'''
payload = '''	beattoolsAlpha = alpha,'''
position = "after"
target = "levelformat/events/Notes/mineHold.lua"

# Place custom event ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.placeEvent ~= '' and Event.info[self.placeEvent] then'''
payload = '''
if self.placeEvent ~= '' and self.placeEvent:match("beattoolsEvent;") then
	local placingEvent = { time = self.cursorBeat, angle = self.cursorAngle }
	for w in self.placeEvent:gmatch("[^;]+") do
		if w ~= "beattoolsEvent" then
			if w:match(",") == nil then
				placingEvent.type = w
			else
				local temp = {}
				for ww in w:gmatch("[^,]+") do
					table.insert(temp, ww)
				end
				if false then end
				({
					string = function () end,
					number = function () temp[2] = tonumber(temp[2]) end,
					boolean = function () temp[2] = temp[2] == "true" and true or false end,
					["nil"] = function () temp[2] = nil end
				})[temp[3]]()
				placingEvent[temp[1]] = temp[2]
			end
		end
	end
	if Event.info[placingEvent.type] then
		table.insert(self.level.events, placingEvent)
		self:noSelection()
		self.selectedEvent = self.level.events[#self.level.events]
		self.unsavedChanges = true
		self:updateBiggestBeat()
	else
		modlog(mods.beattools, "Invalid customized event type: \"" .. tostring(placingEvent.type) .. "\"")
	end
elseif self.placeEvent ~= '' and Event.info[self.placeEvent] then
'''
position = "at"
target = "states/Editor.lua"

# Acc bar ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if cs.vfx.drawCombo and cs.vfx.drawUI then'''
payload = '''
if mods.beattools.config.accBar then
	local realAcc = (((cs.currentMaxHits or 1) - (cs.misses or 0) - ((cs.barelies or 0) / 4)) / (cs.currentMaxHits or 1))
	if realAcc ~= realAcc then realAcc = 1 end
	if cs.beattoolsPrevAcc == nil or cs.beattoolsPrevAcc ~= cs.beattoolsPrevAcc then cs.beattoolsPrevAcc = realAcc end
	local acc = cs.beattoolsPrevAcc + (realAcc - cs.beattoolsPrevAcc) * mods.beattools.config.accBarSmooth
	cs.beattoolsPrevAcc = acc
	if acc > 0 then
		local gradeMargins = {
			{100, 'perfect'},
			{98, 's','plus'},
			{95, 's'},
			{93, 'a','plus'},
			{90, 'a'},
			{87, 'b','plus'},
			{83, 'b'},
			{80, 'b','minus'},
			{77, 'c','plus'},
			{73, 'c'},
			{70, 'c','minus'},
			{64, 'd','plus'},
			{56, 'd'},
			{50, 'd','minus'},
			{0, 'f'}
		}
		for i, v in ipairs(gradeMargins) do
			if acc * 100 >= v[1] then
				local accBarBgColors = { note = 0, player = cs.p.fillColor, ["UI/BG"] = cs.bgColor, ["outline/BG"] = cs.bgColor }
				local accBarFgColors = { note = 1, player = cs.p.outlineColor, ["UI/BG"] = cs.vfx.uiColor, ["outline/BG"] = cs.outline or 0 }
				local accBarColorScheme = mods.beattools.config.accBarColors
				if accBarColorScheme == "auto" then
					local accBarColorDiff
					for k, vv in pairs(accBarBgColors) do
						local colorDiff = math.abs((shuv.pal[accBarFgColors[k]].r + shuv.pal[accBarFgColors[k]].g + shuv.pal[accBarFgColors[k]].b) - (shuv.pal[vv].r + shuv.pal[vv].g + shuv.pal[vv].b))
						if accBarColorDiff == nil or accBarColorDiff < colorDiff then
							accBarColorScheme = k
							accBarColorDiff = colorDiff
						end
					end
				end
				local subAcc = 0
				local subAcc2 = 1
				local drawBar = ({
					top = function ()
						love.graphics.rectangle(
							"fill",
							project.res.x * subAcc, 0,
							project.res.x * subAcc2, mods.beattools.config.accBarWidth
						)
					end,
					bottom = function ()
						love.graphics.rectangle(
							"fill",
							project.res.x * subAcc, project.res.y - mods.beattools.config.accBarWidth,
							project.res.x * subAcc2, project.res.y
						)
					end,
					left = function ()
						love.graphics.rectangle(
							"fill",
							0, project.res.y * subAcc,
							mods.beattools.config.accBarWidth, project.res.y * subAcc2
						)
					end,
					right = function ()
						love.graphics.rectangle(
							"fill",
							project.res.x - mods.beattools.config.accBarWidth, project.res.y * subAcc,
							project.res.x, project.res.y * subAcc2
						)
					end
				})[mods.beattools.config.accBarSide]
				if v[2] ~= "perfect" then
					color(accBarBgColors[accBarColorScheme])
					drawBar()
					if mods.beattools.config.accBarReverse then
						subAcc = 1 - (acc * 100 - v[1]) / (gradeMargins[i - 1][1] - v[1])
						subAcc2 = 1
					else
						subAcc = 0
						subAcc2 = (acc * 100 - v[1]) / (gradeMargins[i - 1][1] - v[1])
					end
				end
				color(accBarFgColors[accBarColorScheme])
				drawBar()
				color(cs.vfx.uiColor)
				break
			end
		end
	end
end
'''
position = "before"
target = "obj/GameManager.lua"

# Custom level visuals ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local loadBeatQueue = {}'''
payload = '''
local beattoolsNoColors = true
'''
position = "after"
target = "obj/GameManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if cs.level.properties.loadBeat and cs.cBeat < 0 and v.time <= cs.level.properties.loadBeat then'''
payload = '''
if mods.beattools.config.customLevelVisuals then
	if v.type == "setColor" then
		beattoolsNoColors = false
	elseif v.type == "outline" then
		if not ({ [0] = true, [1] = true })[v.color] then
			beattoolsNoColors = false
		end
	elseif v.type == "noise" then
		if (not ({ [0] = true, [1] = true })[v.color]) then
			beattoolsNoColors = false
		end
	elseif v.type == "setBgColor" then
		if (not ({ [0] = true, [1] = true })[v.color]) and (not ({ [0] = true, [1] = true })[v.voidColor]) then
			beattoolsNoColors = false
		end
	elseif v.type == "deco" then
		if v.hide ~= true then
			beattoolsNoColors = false
		end
	end
end
'''
position = "before"
target = "obj/GameManager.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''table.sort(loadBeatQueue,function(k1, k2)'''
payload = '''
if mods.beattools.config.customLevelVisuals and beattoolsNoColors then
	shuv.pal[0].r, shuv.pal[0].g, shuv.pal[0].b = mods.beattools.config.customWhiteColor.r * 255, mods.beattools.config.customWhiteColor.g * 255, mods.beattools.config.customWhiteColor.b * 255
	shuv.pal[1].r, shuv.pal[1].g, shuv.pal[1].b = mods.beattools.config.customBlackColor.r * 255, mods.beattools.config.customBlackColor.g * 255, mods.beattools.config.customBlackColor.b * 255
end
'''
position = "before"
target = "obj/GameManager.lua"

# Better Level Select ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''function st:newLevel(levelMetadata, filename, originalFilename)'''
# position = "at"
# payload = '''
# function st:loadLevel(index)
# 	local v = self.directoryList[index]
# 	if v == nil then return end
# 	if not self.menuItems[index].beattoolsTemp then return end

# 	local folderInfo = love.filesystem.getInfo(self.currentDirectory .. v .. "/")

# 	if love.filesystem.getInfo(self.currentDirectory .. v .. "/manifest.json") then
# 		local levelMetadata = LevelManager:loadMetadata(self.currentDirectory..v..'/')
# 		self:newLevel(levelMetadata, self.currentDirectory..v..'/', index)
# 	elseif love.filesystem.getInfo(self.currentDirectory .. v .. "/level.json") then
# 		local levelMetadata = LevelManager:loadMetadata(self.currentDirectory..v..'/')
# 		self:newLevel(levelMetadata, self.currentDirectory..v..'/', index)
# 	elseif folderInfo and folderInfo.type == "directory" then
# 		self:newFolder(v, index)
# 	elseif v:match("(.+)%.redirect") then
# 		--Eventually we will need to implement a more robust song unlocking system, but since we only have 1 locked song, this should work. -DPS
# 		local filename = love.filesystem.read(self.currentDirectory..v)
# 		if (not (filename == 'levels/Finished levels/TerabyteConnection/' and (not savedata.terabyteUnlocked))) and
# 			(not (filename == 'levels/Other/fishing/' and (not (self.playedLevelsJson['Tutorial_CV35W_CV35W_easy'] or self.playedLevelsJson['Tutorial_CV35W_DPS2004'])))) then
# 			local levelMetadata = LevelManager:loadMetadata(filename)
# 			self:newLevel(levelMetadata, filename, index)
# 		end
# 	end
# end
# function st:newLevel(levelMetadata, filename, originalFilename, index)
# '''
# match_indent = true

# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''function st:newFolder(filename)'''
# position = "at"
# payload = '''function st:newFolder(filename, index)'''
# match_indent = true

# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''table.insert(self.menuItems, menuItem)'''
# position = "at"
# payload = '''
# if index then
# 	self.menuItems[index] = menuItem
# else
# 	table.insert(self.menuItems, menuItem)
# end
# '''
# match_indent = true

# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''
# local directoryList = love.filesystem.getDirectoryItems(self.currentDirectory)
#   self.menuItems = {}

# -- If it's loading the Songwheel, grab the currently unlocked levels from the save file & add them to the menuItems list.

# if self.currentDirectory == "levels/Songwheel/" then

# 	local unlockData = UnlockManager.getUnlockedMapLevels('levels/AtomMap.json')
# 	print('Unlock Data: ' .. table.concat(unlockData, ', '))
# 	for i, path in ipairs(unlockData) do
# 		if love.filesystem.getInfo(path .. "/manifest.json") then
# 			local levelMetadata = LevelManager:loadMetadata(path .. '/')
# 			self:newLevel(levelMetadata, path.. '/')
# 		elseif love.filesystem.getInfo(path .. "/level.json") then
# 			local levelMetadata = LevelManager:loadMetadata(path .. '/')
# 			self:newLevel(levelMetadata, path .. '/')
# 		elseif love.filesystem.getInfo(path .. "/marathon.json") then
# 			self:newMarathon(path .. '/')
# 		else
# 			print('Error: Level not found at path: ' .. path)
# 		end
# 	end
# end

# -- Checks if we're loading the Marathon menu, and loads any marathons if so.

# -- Still do this code anyway so we can add in levels manually that might not be in the atom map. (Why would we ever do this?)

# 	for i,v in ipairs(directoryList) do
# 		local folderInfo = love.filesystem.getInfo(self.currentDirectory .. v .. "/")

# 		if love.filesystem.getInfo(self.currentDirectory .. v .. "/manifest.json") then
# 			local levelMetadata = LevelManager:loadMetadata(self.currentDirectory..v..'/')
# 			self:newLevel(levelMetadata, self.currentDirectory..v..'/')
# 		elseif love.filesystem.getInfo(self.currentDirectory .. v .. "/level.json") then
# 				local levelMetadata = LevelManager:loadMetadata(self.currentDirectory..v..'/')
# 				self:newLevel(levelMetadata, self.currentDirectory..v..'/')
# 		elseif love.filesystem.getInfo(self.currentDirectory .. v .. "/marathon.json") then
# 				self:newMarathon(self.currentDirectory..v..'/')
# 		elseif folderInfo and folderInfo.type == "directory" then
# 			self:newFolder(v)
# 		elseif v:match("(.+)%.redirect") then

# 			--Eventually we will need to implement a more robust song unlocking system, but since we only have 1 locked song, this should work. -DPS
# 			local filename = love.filesystem.read(self.currentDirectory..v)
# 			if not (filename == 'levels/Other/fishing/' and (not UnlockManager.isLevelPassed({
# 	level = "Finished levels/Rhythmic Shield/",
# 	percent = 80,
# }))) then
# 						local levelMetadata = LevelManager:loadMetadata(filename)
# 						self:newLevel(levelMetadata, filename)
# 			end
# 		end
# 	end

# 	if self.currentDirectory == 'Custom Levels/' then
# 		local menuItem = {}
# 		menuItem.isLevel = false
# 		menuItem.multiLine = true
# 		menuItem.openCustomsFolder = true

# 		menuItem.name = loc.get('openCustomsFolder')
# 		menuItem.artist = loc.get('putLevelsInHere')
# 		if index then
# 			self.menuItems[index] = menuItem
# 		else
# 			table.insert(self.menuItems, menuItem)
# 		end
# 	end
# '''
# position = "at"
# payload = '''
# self.directoryList = love.filesystem.getDirectoryItems(self.currentDirectory)
# self.menuItems = {}
# if not mods.beattools.config.levelSelectShowIncompatible then
# 	for i = #self.directoryList, 1, -1 do
# 		local v = self.directoryList[i]
# 		local folderInfo = love.filesystem.getInfo(self.currentDirectory .. v .. "/")
# 		if love.filesystem.getInfo(self.currentDirectory .. v .. "/manifest.json") or love.filesystem.getInfo(self.currentDirectory .. v .. "/level.json") or (folderInfo and folderInfo.type == "directory") or v:match("(.+)%.redirect") then
# 		else
# 			table.remove(self.directoryList, i)
# 		end
# 	end
# end
# if self.currentDirectory == "levels/Songwheel/" then
# 	local unlockData = UnlockManager.getUnlockedMapLevels('levels/AtomMap.json')
# 	for i, path in ipairs(unlockData) do
# 		if love.filesystem.getInfo(path .. "/manifest.json") then
# 			local levelMetadata = LevelManager:loadMetadata(path .. '/')
# 			self:newLevel(levelMetadata, path.. '/')
# 		elseif love.filesystem.getInfo(path .. "/level.json") then
# 			local levelMetadata = LevelManager:loadMetadata(path .. '/')
# 			self:newLevel(levelMetadata, path .. '/')
# 		elseif love.filesystem.getInfo(path .. "/marathon.json") then
# 			self:newMarathon(path .. '/')
# 		else
# 			print('Error: Level not found at path: ' .. path)
# 		end
# 	end
# end
# if self.currentDirectory == 'Custom Levels/' then
# 	for i, v in ipairs(self.directoryList) do
# 		self.menuItems[i] = {
# 			multiLine = true,
# 			name = '"' .. tostring(v) .. '"',
# 			artist = self.topDirectory == "Custom Levels/" and "  [ Invalid file ]  " or "  [ Locked Level ]  ",
# 			beattoolsTemp = true
# 		}
# 		if not mods.beattools.config.levelSelectDynamicLoading then
# 			st:loadLevel(i)
# 		end
# 	end
# end
# '''
# match_indent = true

# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''function st:updateSelection()'''
# position = "after"
# payload = '''
# 	if mods.beattools.config.levelSelectDynamicLoading then
# 		for i = -3, 3 do
# 			st:loadLevel(self.selection + i)
# 		end
# 	end
# '''
# match_indent = true

# [[patches]]
# [patches.pattern]
# target = "states/SongSelect.lua"
# pattern = '''if maininput:pressed("accept") or clickedOnLevel then'''
# position = "after"
# payload = '''
# 	if self.menuItems[self.selection].beattoolsTemp then return end
# '''
# match_indent = true

# Bpm with rateMod ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''level.metadata.bpm = loc.get('bpm',{level.metadata.bpm})'''
payload = '''level.metadata.rawBpm = level.metadata.bpm'''
position = "before"
target = "obj/LevelManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''level.metadata.bpm = minBPM .. '-' .. maxBPM'''
payload = '''
level.metadata.rawMinBpm = minBPM
level.metadata.rawMaxBpm = maxBPM
'''
position = "before"
target = "obj/LevelManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''love.graphics.printf(level.bpm,xBorder+xOffset,bpmY,wrapLimit,'left')'''
payload = '''
if mods.beattools.config.levelSelectMultiplyBpm and self.rateMod and self.rateMod ~= 1 then
	if type(level.rawMetadata.rawBpm) == "number" then
		love.graphics.printf(loc.get("bpm", { level.rawMetadata.rawBpm * self.rateMod .. " (" .. level.rawMetadata.rawBpm .. " x" .. self.rateMod .. ")" }), xBorder + xOffset, bpmY, wrapLimit, "left")
	elseif type(level.rawMetadata.rawMinBpm) == "number" then
		love.graphics.printf(loc.get("bpm", { level.rawMetadata.rawMinBpm * self.rateMod .. "-" .. level.rawMetadata.rawMaxBpm * self.rateMod .. " (" .. level.rawMetadata.rawBpm .. " x" .. self.rateMod .. ")" }), xBorder + xOffset, bpmY, wrapLimit, "left")
	end
else
	love.graphics.printf(level.bpm,xBorder+xOffset,bpmY,wrapLimit,'left')
end
'''
position = "at"
target = "states/SongSelect.lua"

# Fix play sound annoyance ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local oLTotal = 0'''
payload = '''cs.loadingBeats = true'''
position = "before"
target = "obj/GameManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''prof.pop("GameManager update")'''
payload = '''cs.loadingBeats = false'''
position = "after"
target = "obj/GameManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''te.playOne(sounds[event.sound] or cs.soundEffects[event.sound], "static",'sfx', event.volume, event.pitch)'''
payload = '''
if not cs.loadingBeats then
	te.playOne(sounds[event.sound] or cs.soundEffects[event.sound], "static",'sfx', event.volume, event.pitch)
end
'''
position = "at"
target = "levelformat/events/Vfx/playSound.lua"

# Cheat ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''function GameManager:resetLevel()'''
payload = '''	self.CHEATmaxBeat = nil'''
position = "after"
target = "obj/GameManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''function GameManager:update(dt)'''
payload = '''
function GameManager:CHEATconvertToBeat(number, forceSeconds)
	if forceSeconds or mods.beattools.config.lagUseSeconds then
		return number / (60 / GameManager:getBPM() / (GameManager.rateMod or 1))
	end
	return number
end

'''
position = "before"
target = "obj/GameManager.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''cs.cBeat = cs.source:getBeat()'''
payload = '''
local tempTime = cs.source:getBeat()
-- Penta:
-- cs.cBeat is the old one
-- tempTime is the new one
if mods.beattools.config.lagBack and (not maininput:down("modifier")) and cs.cBeat + self:CHEATconvertToBeat(mods.beattools.config.lagThreshhold) <= tempTime then
	forceprint("LAG DETECTED!!!")
	if self.CHEATmaxBeat == nil or cs.cBeat > self.CHEATmaxBeat then self.CHEATmaxBeat = cs.cBeat end
	tempTime = (self.CHEATmaxBeat or 0) - self:CHEATconvertToBeat(mods.beattools.config.lagOffset)
	if cs.cBeat - tempTime >= 3 then table.insert(cs.playEvents, { angle = 0, time = cs.cBeat - 3, type = 'playSound', volume = '1', pitch = '0.5', sound = 'click', soundObject = sounds['click']}) end
	if cs.cBeat - tempTime >= 2 then table.insert(cs.playEvents, { angle = 0, time = cs.cBeat - 2, type = 'playSound', volume = '1', pitch = '1.5', sound = 'side', soundObject = sounds['side']}) end
	if cs.cBeat - tempTime >= 1 then table.insert(cs.playEvents, { angle = 0, time = cs.cBeat - 1, type = 'playSound', volume = '1', pitch = '1.5', sound = 'side', soundObject = sounds['side']}) end
	if cs.cBeat - tempTime >= 0 then table.insert(cs.playEvents, { angle = 0, time = cs.cBeat - 0, type = 'playSound', volume = '1', pitch = '1.75', sound = 'side', soundObject = sounds['side']}) end
	cs.pauseBeat = cs.cBeat
	cs.source:setBeat(tempTime)
	self.CHEATlagBack = (self.CHEATlagBack or 0) + 1
end
cs.cBeat = tempTime
'''
position = "at"
target = "obj/GameManager.lua"

# Better multiselect move ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''v.time = v.time + deltaBeat'''
payload = '''
if mods.beattools.config.betterMoveSelection and v.endAngle then
	v.endAngle = v.endAngle * deltaScale + deltaAngle
end
'''
position = "before"
target = "states/Editor.lua"

# Fix multiselect bug with untagger ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if changed then'''
payload = '''if (function () for k, v in pairs(changed) do return true end return false end)() then'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if first[k] ~= v then'''
payload = '''if tostring(first[k]) ~= tostring(v) then'''
position = "at"
target = "states/Editor.lua"

# Menumusicmanager in Song Select ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.menuMusicManager:stop()
cLevel = filename'''
payload = '''
if self.menuMusicManager and not (mods.beattools.config.menuMusicInEditor and savedata.options.audio.playMenuMusic) then
	self.menuMusicManager:stop()
end
cLevel = filename
'''
position = "at"
target = "states/SongSelect.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''cs = bs.load('Editor')'''
payload = '''
if self.menuMusicManager then
	self.menuMusicManager:clearOnBeatHooks()
	self.menuMusicManager:forceUnmute()
	cs.menuMusicManager = self.menuMusicManager
end
'''
position = "after"
target = "states/SongSelect.lua"

# End angle fix ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(self.selectedEvent, 'decimal', 'time', 'Beat to activate on', { step = beatStep })'''
payload = '''local beattoolsTemp1 = self.selectedEvent.endAngle'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if imgui.Button('Delete event') then'''
payload = '''
if self.selectedEvent and beattoolsTemp1 == nil and self.selectedEvent.endAngle == 0 then
	utilitools.files.beattools.undo.undoing = true
	utilitools.files.beattools.undo.fakeRepeating = true
	self.selectedEvent.endAngle = self.selectedEvent.angle
	utilitools.files.beattools.undo.undoing = false
	utilitools.files.beattools.undo.fakeRepeating = false
end
'''
position = "before"
target = "states/Editor.lua"

# Angle/Beat snap saving ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''imgui.Text("Angle: " .. angleSnapText)
end'''
payload = '''
mods.beattools.config.angleSnap = self.angleSnap
mods.beattools.config.customAngleSnap = self.customAngleSnap
'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.angleSnapValues = { 8, 12, 16, 24, 32 }
self.angleSnap = 3
self.customAngleSnap = 32'''
payload = '''
self.angleSnapValues = mods.beattools.config.angleSnapValues
self.angleSnap = mods.beattools.config.saveAngleBeatSnap and mods.beattools.config.angleSnap or mods.beattools.config.angleDefault
self.customAngleSnap = mods.beattools.config.saveAngleBeatSnap and mods.beattools.config.customAngleSnap or mods.beattools.config.customAngleDefault

self.beattoolsMenuMusicInEditorOn = mods.beattools.config.menuMusicInEditor
if not self.menuMusicManager then
	self.menuMusicManager = em.init("MenuMusicManager")
	self.menuMusicManager:play()
	if not (mods.beattools.config.menuMusicInEditor and savedata.options.audio.playMenuMusic) then
		self.menuMusicManager:stop()
	end
end
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''imgui.Text("Beat: " .. beatSnapText)
end'''
payload = '''
mods.beattools.config.beatSnap = self.beatSnap
mods.beattools.config.customBeatSnap = self.customBeatSnap
'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.beatSnapValues = { 1, 2, 3, 4, 5, 6, 8, 12, 16 }
self.beatSnap = 2
self.customBeatSnap = 16'''
payload = '''
self.beatSnapValues = mods.beattools.config.beatSnapValues
self.beatSnap = mods.beattools.config.saveAngleBeatSnap and mods.beattools.config.beatSnap or mods.beattools.config.beatDefault
self.customBeatSnap = mods.beattools.config.saveAngleBeatSnap and mods.beattools.config.customBeatSnap or mods.beattools.config.customBeatDefault
'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self:leave()'''
payload = '''utilitools.config.save(mods.beattools)'''
position = "before"
target = "states/Editor.lua"

# Adjusting zoom limits ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.zoom = math.min(math.max(self.zoom + mouse.sy * 2, 20), 300)'''
payload = '''self.zoom = math.min(math.max(self.zoom + mouse.sy * 2, mods.beattools.config.zoomMin), mods.beattools.config.zoomMax)'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.drawDistance = 10'''
payload = '''self.drawDistance = mods.beattools.config.editorBeats'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.regex]
pattern = '''self\.zoom, self\.smallestBeat\)'''
payload = '''self.zoom, self.smallestBeat - mods.beattools.config.scrollPast)'''
position = "at"
target = "states/Editor.lua"

# Drag threshhold ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if helpers.distance({ self.lastClickX, self.lastClickY }, { mouse.rx, mouse.ry }) >= 10 then'''
payload = '''if helpers.distance({ self.lastClickX, self.lastClickY }, { mouse.rx, mouse.ry }) >= mods.beattools.config.dragThreshhold then'''
position = "at"
target = "states/Editor.lua"

# Draw less ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = false
pattern = '''
--folder
love.graphics.print(v.name,x+10,y-15,0,2,2)
'''
payload = '''
		end
'''
position = "after"
target = "states/SongSelect.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''yTotal = yTotal + myHeight'''
payload = '''if y - myHeight * 0.5 < 360 or y + myHeight * 0.5 > 0 then'''
position = "after"
target = "states/SongSelect.lua"

# Undo save all ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if love.timer.getTime() - self.lastSaved > 300 then'''
payload = '''
	if #utilitools.files.beattools.undo.changes == utilitools.files.beattools.undo.index then
		utilitools.files.beattools.undo.fullSave()
	end
'''
position = "after"
target = "states/Editor.lua"
