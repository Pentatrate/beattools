[manifest]
dump_lua = true
priority = 0
version = "1.0.0"

# Hotkeys ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''function st:checkKeybinds()'''
payload = '''
	utilitools.keybinds.checkBinds(mods.beattools, utilitools.files.beattools.editorKeys)
'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''end, 'delete selected event', 'delete')'''
payload = '''
-- fold all config
self:addKeybind(function ()
	if self.editMode and mods.beattools.config.editorMenu then mods.beattools.config.foldAll = true end
end, "fold all config", "f")
-- move to next
self:addKeybind(function ()
	if mods.beattools.config.jumpEvents then
		if self.multiselect then
			local closest = nil
			for i, v in ipairs(self.multiselect.events) do
				if v.time > self.editorBeat and (closest == nil or ((maininput:down("shift") and closest < v.time) or ((not maininput:down("shift")) and closest > v.time))) then closest = v.time end
			end
			if closest ~= nil then self.editorBeat = closest end
		elseif self.selectedEvent then
			self.editorBeat = self.selectedEvent.time
		else
			local closest = nil
			for i, v in ipairs(self.level.events) do
				if ((not mods.beattools.config.fakeRepeat) or v.beattoolsRepeatChild == nil) and not ({ ghost = true, hide = true })[self:beattoolsGetEventVisibility(v)] and v.time > self.editorBeat and (closest == nil or ((maininput:down("shift") and closest < v.time) or ((not maininput:down("shift")) and closest > v.time))) then closest = v.time end
			end
			if closest ~= nil then self.editorBeat = closest end
		end
	end
end, "move to next", "ctrl", "move_up")
-- move to previous
self:addKeybind(function ()
	if mods.beattools.config.jumpEvents then
		if self.multiselect then
			local closest = nil
			for i, v in ipairs(self.multiselect.events) do
				if v.time < self.editorBeat and (closest == nil or ((maininput:down("shift") and closest > v.time) or ((not maininput:down("shift")) and closest < v.time))) then closest = v.time end
			end
			if closest ~= nil then self.editorBeat = closest end
		elseif self.selectedEvent then
			self.editorBeat = self.selectedEvent.time
		else
			local closest = nil
			for i, v in ipairs(self.level.events) do
				if ((not mods.beattools.config.fakeRepeat) or v.beattoolsRepeatChild == nil) and not ({ ghost = true, hide = true })[self:beattoolsGetEventVisibility(v)] and v.time < self.editorBeat and (closest == nil or ((maininput:down("shift") and closest > v.time) or ((not maininput:down("shift")) and closest < v.time))) then closest = v.time end
			end
			if closest ~= nil then self.editorBeat = closest end
		end
	end
end, "move to previous", "ctrl", "move_down")
'''
position = "after"
target = "states/Editor.lua"

# Prevent ctrl hotkey overlap ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if (self.deltaTimeCooldown <= 0) and (not maininput:down('alt')) then'''
payload = '''if (self.deltaTimeCooldown <= 0) and (not maininput:down('alt')) and ((not mods.beattools.config.jumpEvents) or (not maininput:down("ctrl"))) then'''
position = "at"
target = "states/Editor.lua"

# Exit mouse capture ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.unsavedChanges then'''
payload = '''
if beattoolsRecordPosition then
	beattoolsRecordPosition = false
	beattoolsRecordFunc = nil
	beattoolsRecordPrecision = 1
elseif self.unsavedChanges then
'''
position = "at"
target = "states/Editor.lua"

# Spread events ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''imgui.Text("Select which event to edit:")'''
payload = '''
if mods.beattools.config.spreadButtons then
	local beattoolsShowSpreadPrompt = true
	for i, v in ipairs(self.overlappingEvents) do
		if type(Event.editorDraw[self.level.events[v].type]) ~= "function" and self.level.events[v].time ~= self.level.events[self.overlappingEvents[1]].time then
			beattoolsShowSpreadPrompt = false
		end
	end
	if beattoolsShowSpreadPrompt then
		local function beattoolsGetSameTime(sameTime)
			for i, v in ipairs(self.level.events) do
				if v.time == self.level.events[self.overlappingEvents[1]].time then
					table.insert(sameTime, v)
				end
			end
		end
		local function beattoolsSnapAngle(angle, snap)
			return ((math.floor(angle / (360 / snap) + 0.5) * (360 / snap))) % 360
		end
		local function beattoolsSameAngle(event, sameTime)
			for i, v in ipairs(sameTime) do
				if event.angle % 360 == v.angle % 360 and event ~= v then
					return true
				end
			end
			return false
		end
		local function beattoolsSpread(snap, sameTime, snappedAngle, event)
			if snappedAngle == nil then
				if event == nil then
					utilitools.prompts.error(mods.beattools, "Spread incorrect: snappedAngle is nil")
					modlog(mods.beattools, "Spread incorrect: snappedAngle is nil")
					snappedAngle = 0
				else
					snappedAngle = beattoolsSnapAngle(event.angle, snap)
				end
			end
			local newAngle
			for ii = 1, snap - 1 do
				if mods.beattools.config.spreadType == "around" then
					newAngle = (snappedAngle + 360 / snap * math.floor((ii + 1) / 2) * ((ii % 2) - 0.5) * 2) % 360
				elseif mods.beattools.config.spreadType == "clockwise" then
					newAngle = (snappedAngle + 360 / snap * ii) % 360
				elseif mods.beattools.config.spreadType == "counterclockwise" then
					newAngle = (snappedAngle + 360 / snap * -ii) % 360
				elseif mods.beattools.config.spreadType == "absolute" then
					newAngle = (360 / snap * ii) % 360
				end
				if newAngle == -0 then newAngle = 0 end
				local beattoolsFree = true
				for iii, vv in ipairs(sameTime) do
					if newAngle == vv.angle % 360 then -- Penta: vv.angle cannot be -0
						beattoolsFree = false
						break
					end
				end
				if beattoolsFree then break end
				if ii == snap - 1 then
					return beattoolsSpread(snap * 2, sameTime, snappedAngle)
				end
			end
			return newAngle
		end


		if imgui.Button("Spread events") then
			local beattoolsSameTime = {}
			beattoolsGetSameTime(beattoolsSameTime)
			for i, v in ipairs(self.overlappingEvents) do
				v = self.level.events[v]
				if type(Event.editorDraw[v.type]) ~= "function" and beattoolsSameAngle(v, beattoolsSameTime) then
					v.angle = beattoolsSpread(mods.beattools.config.spreadSnap, beattoolsSameTime, nil, v)
				end
			end
			for i, v in ipairs(self.overlappingEvents) do
				v = self.level.events[v]
				if type(Event.editorDraw[v.type]) ~= "function" and v.angle % 360 ~= beattoolsSnapAngle(v.angle, mods.beattools.config.spreadSnap) then
					v.angle = beattoolsSpread(mods.beattools.config.spreadSnap, beattoolsSameTime, nil, v)
				end
			end
			self:updateBiggestBeat()
			self.overlappingEventsDialogue = false
		end


		beattoolsShowSpreadPrompt = true
		for i, v in ipairs(self.overlappingEvents) do
			if self.level.events[v].angle % 360 ~= self.level.events[self.overlappingEvents[1]].angle % 360 then
				beattoolsShowSpreadPrompt = false
			end
		end
		if beattoolsShowSpreadPrompt then
			if imgui.Button("Spread all events at angle") then
				local beattoolsSameTime, beattoolsAngle = {}, self.level.events[self.overlappingEvents[1]].angle % 360
				beattoolsGetSameTime(beattoolsSameTime)
				for i, v in ipairs(beattoolsSameTime) do
					if type(Event.editorDraw[v.type]) ~= "function" and v.angle % 360 == beattoolsAngle and (v.angle % 360 ~= beattoolsSnapAngle(v.angle, mods.beattools.config.spreadSnap) or beattoolsSameAngle(v, beattoolsSameTime)) then
						v.angle = beattoolsSpread(mods.beattools.config.spreadSnap, beattoolsSameTime, nil, v)
					end
				end
				self:updateBiggestBeat()
				self.overlappingEventsDialogue = false
			end
		end


		if imgui.Button("Spread all events at time") then
			local beattoolsSameTime = {}
			beattoolsGetSameTime(beattoolsSameTime)
			for i, v in ipairs(beattoolsSameTime) do
				if type(Event.editorDraw[v.type]) ~= "function" and beattoolsSameAngle(v, beattoolsSameTime) then
					v.angle = beattoolsSpread(mods.beattools.config.spreadSnap, beattoolsSameTime, nil, v)
				end
			end
			for i, v in ipairs(beattoolsSameTime) do
				if type(Event.editorDraw[v.type]) ~= "function" and v.angle % 360 ~= beattoolsSnapAngle(v.angle, mods.beattools.config.spreadSnap) then
					v.angle = beattoolsSpread(mods.beattools.config.spreadSnap, beattoolsSameTime, nil, v)
				end
			end
			self:updateBiggestBeat()
			self.overlappingEventsDialogue = false
		end
	end
end
'''
position = "after"
target = "states/Editor.lua"

# Deselect ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.selectedEvent = nil'''
payload = '''if mods.beattools.config.deleteNothing and self.selectedEvent == nil and self.placeEvent ~= "" then
	self.placeEvent = ""
end
'''
position = "before"
target = "states/Editor.lua"

# Fake repeat and (un)tagging buttons ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if imgui.Button('Delete event') then'''
payload = '''
if self.selectedEvent and self.selectedEvent.type == "ease" and mods.beattools.config.easeCurrentValues then
	if beattools.easeList.unsorted.all[self.selectedEvent.var] ~= nil and self.selectedEvent.var ~= "outline" then
		self:beattoolsCurrentEasing("ease", "var", "editorBeat", self.selectedEvent.var)
		self:beattoolsCurrentEasing("ease", "var", self.selectedEvent.time, self.selectedEvent.var, nil, self:eventIndex(self.selectedEvent))
		local eventTime = self.beattoolsCurrentEasings[self.selectedEvent.time].ease[self.selectedEvent.var][type(beattools.easeList.unsorted.all[self.selectedEvent.var]) == "boolean" and "enable" or "value"]
		local editorTime = self.beattoolsCurrentEasings.editorBeat.ease[self.selectedEvent.var][type(beattools.easeList.unsorted.all[self.selectedEvent.var]) == "boolean" and "enable" or "value"]
		if mods.beattools.config.easeListRound then
			if type(eventTime) == "number" then
				eventTime = helpers.round(eventTime * 1e3) / 1e3
			end
			if type(editorTime) == "number" then
				editorTime = helpers.round(editorTime * 1e3) / 1e3
			end
		end
		imgui.Text(
			"Value at event time: " ..
			tostring(eventTime) ..
			"\nValue at editor beat: " ..
			tostring(editorTime)
		)
	else
		imgui.Text("Invalid Ease")
	end
	imgui.Separator()
end
if self.selectedEvent and mods.beattools.config.fakeRepeat and not beattools.noFakeRepeat[self.selectedEvent.type] then
	Event.property(self.selectedEvent, "int", "repeats", "Times to repeat", {optional = true, default = 0})
	if self.selectedEvent.repeats and self.selectedEvent.repeats > 0 then
		Event.property(self.selectedEvent, "decimal", "repeatDelay", "Beats between repeats", {step = cs:getBeatStep(), default = 1})
	else self.selectedEvent.repeatDelay = nil end
	if self.selectedEvent.repeats and self.selectedEvent.repeats > 0 and self.selectedEvent.repeatDelay and imgui.Button("Convert##beattools") then
		utilitools.prompts.confirm("Converting to real events will lose the functionality of changes of the main event cascading to repeated events", function ()
			utilitools.files.beattools.fakeRepeat.update(self.selectedEvent, true)
		end)
	end
	imgui.Separator()
end
if self.selectedEvent and mods.beattools.config.showEventGroups then
	if self.level.properties.beattools.customEventGroups then
		if imgui.TreeNode_Str("Event Groups##beattoolsSelectedEventGroups") then
			local hasAllCustomGroups = true
			for k, v in pairs(self.level.properties.beattools.customEventGroups) do
				if not (self.selectedEvent.beattoolsCustomEventGroups and self.selectedEvent.beattoolsCustomEventGroups[k]) then
					hasAllCustomGroups = false
					break
				end
			end
			if not hasAllCustomGroups then
				local isOpen = imgui.BeginCombo("##beattoolsAddSelectedEventGroup", "Add Custom Event Group", 2^4 + 2^5 + 2^7)
				if isOpen then
					for k, v in pairs(self.level.properties.beattools.customEventGroups) do
						if not (self.selectedEvent.beattoolsCustomEventGroups and self.selectedEvent.beattoolsCustomEventGroups[k]) then
							local selected = imgui.Selectable_Bool(k .. "##beattoolsAddSelectedEventGroup")
							if selected then
								if self.selectedEvent.beattoolsCustomEventGroups == nil then self.selectedEvent.beattoolsCustomEventGroups = {} end
								self.selectedEvent.beattoolsCustomEventGroups[k] = true
							end
						end
					end
					imgui.EndCombo()
				end
			end
			local selectedCustomEventGroups = 0
			if self.selectedEvent.beattoolsCustomEventGroups then
				for k, v in pairs(self.selectedEvent.beattoolsCustomEventGroups) do
					if self.level.properties.beattools.customEventGroups[k] then
						if imgui.Button(k .. "##beattoolsSelectedEventGroup") then
							self.selectedEvent.beattoolsCustomEventGroups[k] = nil
						end
						selectedCustomEventGroups = selectedCustomEventGroups + 1
					else
						self.selectedEvent.beattoolsCustomEventGroups[k] = nil
					end
				end
				if selectedCustomEventGroups == 0 then
					self.selectedEvent.beattoolsCustomEventGroups = nil
				end
			end
			imgui.TreePop()
		end
		imgui.Separator()
	elseif self.selectedEvent.beattoolsCustomEventGroups then
		self.selectedEvent.beattoolsCustomEventGroups = nil
	end
end
if self.selectedEvent and mods.beattools.config.roundSelectedTimes then self.selectedEvent.time = helpers.round(self.selectedEvent.time * 1e3) / 1e3 end
if self.selectedEvent and mods.beattools.config.untaggingButtons then
	if imgui.Button('Change to tag') then
		self.changeToTagDialogue = true
		self.newTagName = ""
	end
	imgui.Separator()
end
if self.selectedEvent and mods.beattools.config.untaggingButtons and self.selectedEvent.type == "tag" then
	if imgui.Button("Untag") then
		self:beattoolsUntag({ self.selectedEvent })
	end
	imgui.SameLine()
	if imgui.Button("Untag same tag name") then
		utilitools.prompts.confirm("Continuing will untag all tags with the tag name \"" .. self.selectedEvent.tag .. "\"!", function ()
			self:beattoolsUntag({ self.selectedEvent.tag })
		end)
	end
	imgui.Separator()
end
'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal','repeatDelay', 'Beats between repeats', {step = cs:getBeatStep(),optional = true, default = 1})'''
payload = '''
if event.repeats and event.repeats > 0 then
	Event.property(event, 'decimal', 'repeatDelay', 'Beats between repeats', {step = cs:getBeatStep(), default = 1})
else event.repeatDelay = nil end
'''
position = "at"
target = "levelformat/events/Vfx/ease.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if imgui.Button('Delete selected events') then'''
payload = '''
if mods.beattools.config.untaggingButtons then
	if imgui.Button("Untag") then
		self:beattoolsUntag(self.multiselect.events)
	end
	imgui.SameLine()
	if imgui.Button("Untag same tag name") then
		local tempEvents = {}
		for i, v in ipairs(self.multiselect.events) do
			if v.type == "tag" then table.insert(tempEvents, v.tag) end
		end
		utilitools.prompts.confirm("Continuing will untag all tags with the same name as those in the selection!", function ()
			self:beattoolsUntag(tempEvents)
		end)
	end
	imgui.Separator()
end
'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if #self.multiselect.events == 0 and #self.markers == 0 then'''
payload = '''
if mods.beattools.config.convertSingle and self.multiselect and #self.multiselect.events == 1 and #self.markers == 0 then
	self.selectedEvent = self.multiselect.events[1]
	self:clearMultiselectVars()
end
if self.multiselect and #self.multiselect.events == 0 and #self.markers == 0 then
'''
position = "at"
target = "states/Editor.lua"

# Tagging but idk whats going on ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.changeToTagDialogue = true'''
payload = '''self.firstTimeTagDialogue = true'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''self.newTagName = helpers.InputText("Tag name", self.newTagName, 9999)'''
payload = '''
if self.firstTimeTagDialogue then
	self.firstTimeTagDialogue = false
	imgui.SetKeyboardFocusHere()
end
'''
position = "before"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''{ type = 'tag', angle = 0, time = self.multiselectStartBeat, tag = self.newTagName, angleOffset = false })'''
payload = '''{ type = 'tag', angle = 0, time = self.multiselectStartBeat or self.selectedEvent.time, tag = self.newTagName, angleOffset = false })
self:deleteSelectedEvent()'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''if self.changeToTagDialogue and (not self.multiselect) then'''
payload = '''if self.changeToTagDialogue and (not (self.multiselect or self.selectedEvent)) then'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''local tagEvents = helpers.copy(self.multiselect.events)'''
payload = '''local tagEvents = helpers.copy(self.multiselect and self.multiselect.events or { self.selectedEvent })'''
position = "at"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''
love.filesystem.forceSaveInSource(false)

for i, v in ipairs(self.multiselect.events) do
	for _i, _v in ipairs(self.level.events) do
		if _v == v then
			table.remove(self.level.events, _i)
		end
	end
end
self.multiselect.events = {}
'''
payload = '''love.filesystem.forceSaveInSource(false)'''
position = "at"
target = "states/Editor.lua"

# Coordinate copy ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal','y', 'Y position', {step = 1, optional = true, default = project.res.cy})'''
payload = '''
if mods.beattools.config.mouseCoordsButton then
	local pressed = imgui.Button("Use Mouse")
	utilitools.imguiHelpers.tooltip("Copy mouse coordinates")
	if pressed then
		local tempFunc = function ()
			utilitools.prompts.buttons("Choose axis", {
				{ "Both", function ()
					beattoolsRecordPosition = true
					beattoolsRecordFunc = function (x, y) event.x = x event.y = y end
				end },
				{ "X", function ()
					beattoolsRecordPosition = true
					beattoolsRecordFunc = function (x, y) event.x = x end
				end },
				{ "Y", function ()
					beattoolsRecordPosition = true
					beattoolsRecordFunc = function (x, y) event.y = y end
				end }
			})
		end
		utilitools.prompts.buttons("Choose precision", {
			{ "1px", function ()
				beattoolsRecordPrecision = 1
				tempFunc()
			end },
			{ "5px", function ()
				beattoolsRecordPrecision = 5
				tempFunc()
			end },
			{ "10px", function ()
				beattoolsRecordPrecision = 10
				tempFunc()
			end },
			{ "30px", function ()
				beattoolsRecordPrecision = 30
				tempFunc()
			end },
			{ "60px", function ()
				beattoolsRecordPrecision = 60
				tempFunc()
			end },
			{ "90px", function ()
				beattoolsRecordPrecision = 90
				tempFunc()
			end },
			{ "100px", function ()
				beattoolsRecordPrecision = 100
				tempFunc()
			end }
		})
	end
end
'''
position = "after"
target = "levelformat/events/Vfx/deco.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'value', 'Ending value', {step = 0.01, default = 0})'''
payload = '''
if event.var ~= nil then
	local split = utilitools.string.split(event.var, "%.")
	if mods.beattools.config.angleDials and event.var:sub(-2, -1) == ".r" or ({ ["vfx.angleTwist.offset"] = true })[event.var] or (#split > 0 and (split[#split]:lower():find("angle", nil, true) or split[#split]:lower():find("rotate", nil, true))) then
		event.value = utilitools.suggest.dial(event.value, "selectedEventValue", beattoolsAngleSnap)
	elseif mods.beattools.config.mouseCoordsButton and (event.var:sub(-2, -1) == ".x" or event.var:sub(-2, -1) == ".y") then
		local pressed = imgui.Button("Use Mouse")
		utilitools.imguiHelpers.tooltip("Copy mouse coordinates")
		if pressed then
			local tempFunc = function ()
				beattoolsRecordPosition = true
				beattoolsRecordFunc = function (x, y) event.value = event.var:sub(-2, -1) == ".x" and x or y end
			end
			utilitools.prompts.buttons("Choose precision", {
				{ "1px", function ()
					beattoolsRecordPrecision = 1
					tempFunc()
				end },
				{ "5px", function ()
					beattoolsRecordPrecision = 5
					tempFunc()
				end },
				{ "10px", function ()
					beattoolsRecordPrecision = 10
					tempFunc()
				end },
				{ "30px", function ()
					beattoolsRecordPrecision = 30
					tempFunc()
				end },
				{ "60px", function ()
					beattoolsRecordPrecision = 60
					tempFunc()
				end },
				{ "90px", function ()
					beattoolsRecordPrecision = 90
					tempFunc()
				end },
				{ "100px", function ()
					beattoolsRecordPrecision = 100
					tempFunc()
				end }
			})
		end
	end
end
'''
position = "after"
target = "levelformat/events/Vfx/ease.lua"

# Angle dials ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''imgui.Begin("Event Editor",nil,inputFlag)'''
payload = '''beattoolsAngleSnap = self.angleSnap ~= 0 and self:getAngleSnapValue() or 360'''
position = "after"
target = "states/Editor.lua"

[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(self.selectedEvent, 'decimal', 'angle', 'Angle to activate at', { step = angleStep })'''
payload = '''if mods.beattools.config.angleDials then self.selectedEvent.angle = utilitools.suggest.dial(self.selectedEvent.angle, "selectedEventAngle", beattoolsAngleSnap) end'''
position = "after"
target = "states/Editor.lua"

# End angle
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/block.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/hold.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/inverse.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/mine.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/mineHold.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/side.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at for initial approach', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/bounce.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'endAngle', 'Angle to end up at', {step = cs:getAngleStep(), optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.endAngle then event.endAngle = utilitools.suggest.dial(event.endAngle, "selectedEventEndAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Advanced/trace.lua"

# Bounce
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'rotation', 'Rotation between bounces', {step = cs:getAngleStep(), default = 0})'''
payload = '''if mods.beattools.config.angleDials then event.rotation = utilitools.suggest.dial(event.rotation, "selectedEventRotation", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/bounce.lua"

# Hold
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'angle2', 'Angle for end of the hold', {step = cs:getAngleStep(), default = event.angle})'''
payload = '''if mods.beattools.config.angleDials then event.angle2 = utilitools.suggest.dial(event.angle2, "selectedEventAngle2", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/hold.lua"

# Minehold
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'angle2', 'Angle for end of the hold', {step = cs:getAngleStep(), default = event.angle})'''
payload = '''if mods.beattools.config.angleDials then event.angle2 = utilitools.suggest.dial(event.angle2, "selectedEventAngle2", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Notes/mineHold.lua"

# Trace
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'angle2', 'Angle for end of the trace', {step = cs:getAngleStep(), default = event.angle})'''
payload = '''if mods.beattools.config.angleDials then event.angle2 = utilitools.suggest.dial(event.angle2, "selectedEventAngle2", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Advanced/trace.lua"

# Deco
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal','r', 'Rotation', {step = angleStep, optional = true, default = 0})'''
payload = '''
Event.property(event,'decimal','r', 'Rotation', {step = mods.beattools.config.decoRotation and 1 or angleStep, optional = true, default = 0})
if mods.beattools.config.angleDials and event.r then event.r = utilitools.suggest.dial(event.r, "selectedEventR", beattoolsAngleSnap) end
'''
position = "at"
target = "levelformat/events/Vfx/deco.lua"

# Paddles
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'int', 'newWidth', 'New width to ease to', {default = 70, optional=true})'''
payload = '''if mods.beattools.config.angleDials and event.newWidth then event.newWidth = utilitools.suggest.dial(event.newWidth, "selectedEventNewWidth", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Gameplay/paddles.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'int', 'newAngle', 'New angle to ease to', {default = 0, optional=true})'''
payload = '''if mods.beattools.config.angleDials and event.newAngle then event.newAngle = utilitools.suggest.dial(event.newAngle, "selectedEventNewAngle", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Gameplay/paddles.lua"

# Ease sequence
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(v,'decimal', 'startValue', 'Starting value', {step = 0.01, optional = true, default = 0, uniqueName = 'startValue'..i})'''
payload = '''if mods.beattools.config.angleDials and v.startValue and v.variable == "angle" then v.startValue = utilitools.suggest.dial(v.startValue, "selectedEventStartValue", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Vfx/easeSequence.lua"
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(v,'decimal', 'endValue', 'Ending value', {step = 0.01, default = 0, uniqueName = 'endValue'..i})'''
payload = '''if mods.beattools.config.angleDials and v.variable == "angle" then v.endValue = utilitools.suggest.dial(v.endValue, "selectedEventEndValue", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Vfx/easeSequence.lua"

# Text deco
[[patches]]
[patches.pattern]
match_indent = true
pattern = '''Event.property(event,'decimal', 'r', 'Text rotation', {step = 1, optional = true, default = 0})'''
payload = '''if mods.beattools.config.angleDials and event.r then event.r = utilitools.suggest.dial(event.r, "selectedEventR", beattoolsAngleSnap) end'''
position = "after"
target = "levelformat/events/Vfx/textdeco.lua"
